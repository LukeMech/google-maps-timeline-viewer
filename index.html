<!DOCTYPE html>
<html lang="en">

<!-- -----

 Be sure to set your API key in place of "YOUR_API_KEY"

----  -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Maps Timeline Viewer</title>
    <script src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&libraries=marker,places"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>

	<style>
        body, html {
            height: 100%;
            margin: 0;
            font-family: Arial, sans-serif;
        }
        #container {
            display: flex;
            height: 100%;
        }
        #sidebar {
            width: 300px;
            padding: 10px;
            overflow-y: auto;
            position: relative;
        }
		#datePickerContainer {
		  padding: 16px;
		  background: white;
		  border-bottom: 1px solid #e0e0e0;
		  display: flex;
		  align-items: center;
		  gap: 8px;
		}
        #datePicker {
          flex: 1;
		  padding: 8px;
		  border: 1px solid #ddd;
		  border-radius: 4px;
		  font-size: 14px;
        }
		#prevDayBtn, #nextDayBtn {
		  background: #f8f9fa;
		  border: 1px solid #ddd;
		  border-radius: 4px;
		  padding: 8px 12px;
		  cursor: pointer;
		  font-size: 16px;
		  color: #555;
		  transition: all 0.2s ease;
		}

		#prevDayBtn:hover, nextDayBtn:hover {
		  background: #e9ecef;
		  color: #333;
		}
        #map {
            flex-grow: 1;
        }
        
        .controls-container {
		  padding: 16px;
		  border-bottom: 1px solid #e0e0e0;
		  display: flex;
		  align-items: center;
		  justify-content: center;
		  gap: 8px;
		}
		.control-btn {
		  padding: 12px 20px;
		  background: #4285F4;
		  color: white;
		  border: none;
		  border-radius: 4px;
		  cursor: pointer;
		  font-size: 14px;
		  font-weight: 500;
		  transition: background-color 0.2s ease;
		}
		.control-btn:hover {
		  background: #3367d6;
		}
		.btn-icon {
		  font-size: 12px;
		}

        
        .timeline-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 5px;
            background-color: #f0f0f0;
            cursor: pointer;
            position: relative;
        }
        .timeline-icon-container {
            width: 32px;
            text-align: center;
            padding-right: 12px;
        }
        .place-visit-item {
            background-color: #fffacd;
            border: 1px solid #ffd700;
            padding-top: 10px;
            padding-bottom: 10px;
        }
        .highlighted {
            border: 2px solid #000;
        }
        /*.timeline-item::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 3px;
            height: 100%;
        }*/
        .confirmed-checkmark {
            position: absolute;
            bottom: 5px;
            right: 5px;
            font-size: 12px;
            opacity: 20%;
        }
        .highlighted .confirmed-checkmark{
            opacity: 35%;
        }
        .advanced-marker {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .marker-icon {
            font-size: 24px;
        }
        .marker-label {
            font-size: 12px;
            white-space: nowrap;
        }
        #datePickerContainer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
        }
    </style>

</head>
<body>
<div id="container">
    <div id="sidebar">
        <div id="controls-container">
            <button id="folderPicker" class="control-btn">Choose Folder</button>
            <!--button id="modePicker" class="control-btn">Display Mode</button-->
        </div>
        <div id="datePickerContainer">
            <span id="prevDayBtn">&lt;</span>
            <input type="date" id="datePicker">
            <span id="nextDayBtn">&gt;</span>
        </div>
        <div id="timeline"></div>
    </div>
    <div id="map"></div>
</div>

<script>
    let map;
    let markers = [];
    let polylines = [];
    let infoWindows = [];
    let selectedPolyline = null;
    let timelineData = {};

    function initMap() {
        map = new google.maps.Map(document.getElementById('map'), {
            center: { lat: 25.034170396411103, lng: 121.56456035320929 },
            zoom: 12,
            mapId: "TIMELINE_MAP"
        });
    }

    function createTimelineItem(item, index) {
        const timelineItem = document.createElement('div');
        timelineItem.className = 'timeline-item';
        timelineItem.dataset.index = index;

        if (item.placeVisit) {
            const placeVisit = item.placeVisit;
            const locationName = placeVisit.location.name || (placeVisit.location.semanticType === "TYPE_HOME" ? "Home" : 'Unknown location');
            timelineItem.classList.add('place-visit-item');
            timelineItem.innerHTML = `
            <span class="timeline-icon-container">üìç</span>
            <div>
                <strong class="nametag">${locationName}</strong><br>
                ${moment(placeVisit.duration.startTimestamp).format('hh:mm A')} -
                ${moment(placeVisit.duration.endTimestamp).format('hh:mm A')}
            </div>
        `;
            timelineItem.style.setProperty('--activity-color', '#8B4513');
        } else if (item.activitySegment) {
            const activitySegment = item.activitySegment;
            const distance = (activitySegment.distance || (activitySegment.simplifiedRawPath && activitySegment.simplifiedRawPath.distanceMeters) || 0) / 1000;
            timelineItem.innerHTML = `
            <span class="timeline-icon-container">${getActivityIcon(activitySegment.activityType)}</span>
            <div>
                <strong>${formatActivityType(activitySegment.activityType)}</strong><br>
                ${moment(activitySegment.duration.startTimestamp).format('hh:mm A')} -
                ${moment(activitySegment.duration.endTimestamp).format('hh:mm A')}<br>
                Distance: ${distance.toFixed(2)} km
            </div>
        `;
            timelineItem.style.setProperty('--activity-color', getActivityColor(activitySegment.activityType));
            timelineItem.style.borderRight = `3px solid ${getActivityColor(activitySegment.activityType)}`;
        }

        if (item.placeVisit && item.placeVisit.editConfirmationStatus === "CONFIRMED" ||
            item.activitySegment && item.activitySegment.editConfirmationStatus === "CONFIRMED") {
            const checkmark = document.createElement('span');
            checkmark.className = 'confirmed-checkmark';
            checkmark.textContent = '‚úîÔ∏è';
            timelineItem.appendChild(checkmark);
        }

        return timelineItem;
    }

    async function loadTimelineDataInChunks(selectedDate) {
        clearMap();
        clearSidebar();
        const year = selectedDate.getFullYear();
        const month = selectedDate.toLocaleString('default', { month: 'long' }).toUpperCase();
        const dataKey = `${year}_${month}`;

        if (timelineData[dataKey]) {
			//console.log(timelineData[dataKey]);
            const relevantData = timelineData[dataKey].timelineObjects.filter(item => {
                const itemDate = moment(item.placeVisit ? item.placeVisit.duration.startTimestamp : item.activitySegment.duration.startTimestamp).format('YYYY-MM-DD');
                return itemDate === selectedDate.toISOString().split('T')[0];
            });

            let firstLocationSet = false;

            relevantData.forEach((item, index) => {
                const timelineItem = createTimelineItem(item, index);
                document.getElementById('timeline').appendChild(timelineItem);

                if (!firstLocationSet) {
                    if (item.placeVisit) {
                        const placeVisit = item.placeVisit;
                        const latLng = {
                            lat: placeVisit.location.latitudeE7 / 1e7,
                            lng: placeVisit.location.longitudeE7 / 1e7
                        };
                        map.setCenter(latLng);
                        map.setZoom(15);
                        firstLocationSet = true;
                    } else if (item.activitySegment) {
                        const activitySegment = item.activitySegment;
                        const startLatLng = {
                            lat: activitySegment.startLocation.latitudeE7 / 1e7,
                            lng: activitySegment.startLocation.longitudeE7 / 1e7
                        };
                        map.setCenter(startLatLng);
                        map.setZoom(15);
                        firstLocationSet = true;
                    }
                }
            });

            relevantData.forEach((item, index) => {
                if (item.placeVisit) {
                    renderPlaceVisit(item.placeVisit, index);
                } else if (item.activitySegment) {
                    renderActivitySegment(item.activitySegment, index);
                }
            });
        } else {
            console.log('No data available for the selected date');
        }
    }

    function clearMap() {
        markers.forEach(marker => marker.setMap(null));
        markers = [];
        polylines.forEach(polyline => polyline.setMap(null));
        polylines = [];
        infoWindows.forEach(infoWindow => infoWindow.close());
        infoWindows = [];
    }

    function clearSidebar() {
        const timeline = document.getElementById('timeline');
        timeline.innerHTML = '';
    }

    function renderPlaceVisit(placeVisit, index) {
        var locationName = placeVisit.location.name || (placeVisit.location.semanticType === "TYPE_HOME" ? "Home" : 'Unknown Location');

        const placeService = new google.maps.places.PlacesService(map);
        const request = {
            placeId: placeVisit.location.placeId,
            fields: ["icon", "icon_background_color", "formatted_address", "photos", "website", "name"]
        };

        placeService.getDetails(request, (place, status) => {
			console.log(place);
            if (status === google.maps.places.PlacesServiceStatus.OK) { //  && !place.icon.includes("geocode")
                const pinElement = new google.maps.marker.PinElement({
                    background: place.icon_background_color,
                    glyph: new URL(String(place.icon)),
                });
                
                if (!placeVisit.location.name || placeVisit.location.name === "Unknown Location" || placeVisit.location.name === "Unknown location"){
					locationName = place.name;
				}

                const marker = new google.maps.marker.AdvancedMarkerElement({
                    position: {
                        lat: placeVisit.location.latitudeE7 / 1e7,
                        lng: placeVisit.location.longitudeE7 / 1e7
                    },
                    map: map,
                    content: pinElement.element,
                    title: locationName,
                });

                markers.push(marker);

                const photoUrl = place.photos ? place.photos[0].getUrl({ maxWidth: 200, maxHeight: 200 }) : '';
                const websiteLink = place.website ? `<a href="${place.website}" target="_blank">Website</a><br>` : '';
                const infoWindowContent = `
                <h3>${locationName}</h3>
                <p>${place.formatted_address}</p>
                ${photoUrl ? `<img src="${photoUrl}" alt="${locationName}" style="max-width: 200px; max-height: 200px;"><br>` : ''}
                <p>${moment(placeVisit.duration.startTimestamp).format('hh:mm A')} -
                ${moment(placeVisit.duration.endTimestamp).format('hh:mm A')}</p>
                ${websiteLink}
                <p><a href="https://www.google.com/maps/place/?q=place_id:${placeVisit.location.placeId}" target="_blank">View on Google Maps</a></p>
            `;

                const infoWindow = new google.maps.InfoWindow({
                    content: infoWindowContent
                });
                infoWindows.push(infoWindow);

                // Update the sidebar item with the place icon (& name if needed)
                const sidebarItem = document.querySelector(`.timeline-item[data-index="${index}"]`);
                if (sidebarItem) {
					//if (!place.icon.includes("generic_business") && !place.icon.includes("geocode")){
						const iconContainer = sidebarItem.querySelector('.timeline-icon-container');
						iconContainer.innerHTML = `<img src="${place.icon}" alt="${locationName}" style="width: 24px; height: 24px;">`;
                    //}
                    const nametag = sidebarItem.querySelector('.nametag');
                    nametag.innerHTML = `${locationName}`;
                }

                addMarkerClickListener(marker, infoWindow, sidebarItem);
                addSidebarItemClickListener(sidebarItem, marker, infoWindow);

            } else {
                // Fallback to default marker if icon is "generic_business" or "geocode"
                const marker = new google.maps.Marker({
                    position: {
                        lat: placeVisit.location.latitudeE7 / 1e7,
                        lng: placeVisit.location.longitudeE7 / 1e7
                    },
                    map: map,
                    title: locationName,
                });

                markers.push(marker);

                const photoUrl = place.photos ? place.photos[0].getUrl({ maxWidth: 200, maxHeight: 200 }) : '';
                const websiteLink = place.website ? `<a href="${place.website}" target="_blank">Website</a><br>` : '';
                const infoWindowContent = `
                <h3>${locationName}</h3>
                <p>${place.formatted_address}</p>
                ${photoUrl ? `<img src="${photoUrl}" alt="${locationName}" style="max-width: 200px; max-height: 200px;"><br>` : ''}
                <p>${moment(placeVisit.duration.startTimestamp).format('hh:mm A')} -
                ${moment(placeVisit.duration.endTimestamp).format('hh:mm A')}</p>
                ${websiteLink}
                <p><a href="https://www.google.com/maps/place/?q=place_id:${placeVisit.location.placeId}" target="_blank">View on Google Maps</a></p>
            `;

                const infoWindow = new google.maps.InfoWindow({
                    content: infoWindowContent
                });
                infoWindows.push(infoWindow);

                // Update the sidebar item with the default place icon
                const sidebarItem = document.querySelector(`.timeline-item[data-index="${index}"]`);
                if (sidebarItem) {
                    const iconContainer = sidebarItem.querySelector('.timeline-icon-container');
                    iconContainer.innerHTML = `<img src="https://maps.gstatic.com/mapfiles/place_api/icons/v1/png_71/geocode-71.png" alt="${locationName}" style="width: 24px; height: 24px;">`;
                }

                addMarkerClickListener(marker, infoWindow, sidebarItem);
                addSidebarItemClickListener(sidebarItem, marker, infoWindow);
            }
        });
    }



function renderActivitySegment(activitySegment, index) {
    let path = [];

    // Start by adding the start location to the path
    path.push({
        lat: activitySegment.startLocation.latitudeE7 / 1e7,
        lng: activitySegment.startLocation.longitudeE7 / 1e7
    });

    // Add the detailed path points, giving priority to the most detailed available
    if (activitySegment.simplifiedRawPath && activitySegment.simplifiedRawPath.points) {
        path = path.concat(activitySegment.simplifiedRawPath.points.map(point => ({
            lat: point.latE7 / 1e7,
            lng: point.lngE7 / 1e7
        })));
//this elseif removed in other version *****
    } else if (activitySegment.timelinePath && activitySegment.timelinePath.points) {
        path = path.concat(activitySegment.timelinePath.points.map(point => ({
            lat: point.latE7 / 1e7,
            lng: point.lngE7 / 1e7
        })));
    } else if (activitySegment.waypointPath && activitySegment.waypointPath.waypoints) {
        path = path.concat(activitySegment.waypointPath.waypoints.map(point => ({
            lat: point.latE7 / 1e7,
            lng: point.lngE7 / 1e7
        })));
    }

    // Add the end location to the path
    path.push({
        lat: activitySegment.endLocation.latitudeE7 / 1e7,
        lng: activitySegment.endLocation.longitudeE7 / 1e7
    });

    // Define a line symbol to add arrows to the polyline
    const lineSymbol = {
        path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
    };

    // Create a polyline on the map
    const polyline = new google.maps.Polyline({
        path: path,
        geodesic: true,
        strokeColor: getActivityColor(activitySegment.activityType),
        strokeOpacity: 1.0,
        strokeWeight: 5,
		// don't add arrows all the time *****
        /*icons: [{
            icon: lineSymbol,
            offset: '50%', // Position arrow in the middle of the polyline
            repeat: '100px' // Repeat the arrow along the path for long routes
        }],*/
        map: map
    });

    // Store the polyline so it can be cleared later if needed
    polylines.push(polyline);

    // Find the corresponding sidebar item
    const sidebarItem = document.querySelector(`.timeline-item[data-index="${index}"]`);

    // Add event listeners for user interaction
    addPolylineClickListener(polyline, sidebarItem, path);
    addSidebarItemClickListener(sidebarItem, null, null, polyline, path);
}


    function addMarkerClickListener(marker, infoWindow, timelineItem) {
        marker.addListener('click', () => {
            infoWindows.forEach(iw => iw.close());
            infoWindow.open(map, marker);
            highlightSidebarItem(timelineItem);

            if (selectedPolyline) {
                selectedPolyline.setOptions({ icons: [] });
                selectedPolyline = null;
            }
        });
    }

    function addPolylineClickListener(polyline, timelineItem, path) {
        polyline.addListener('click', () => {
            highlightSidebarItem(timelineItem);
            const bounds = new google.maps.LatLngBounds();
            path.forEach(point => bounds.extend(point));
            map.fitBounds(bounds);

            if (selectedPolyline) {
                selectedPolyline.setOptions({ icons: [] });
            }

            polyline.setOptions({
                icons: [{
                    icon: {
                        path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                        scale: 4
                    },
                    offset: '50%',
                    repeat: '80px'
                }],
            });

            selectedPolyline = polyline;

            // Close all info windows
            infoWindows.forEach(iw => iw.close());

            timelineItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        });
    }

    function addSidebarItemClickListener(sidebarItem, marker, infoWindow, polyline, path) {
        sidebarItem.addEventListener('click', () => {
            if (marker && infoWindow) {
                map.setCenter(marker.position);
                map.setZoom(15);
                infoWindows.forEach(iw => iw.close());
                infoWindow.open(map, marker);
            } else if (polyline && path) {
                const bounds = new google.maps.LatLngBounds();
                path.forEach(point => bounds.extend(point));
                map.fitBounds(bounds);

                if (selectedPolyline) {
                    selectedPolyline.setOptions({ icons: [] });
                }

                polyline.setOptions({
                    icons: [{
                        icon: {
                            path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                            scale: 4
                        },
                        offset: '50%',
                        repeat: '80px'
                    }],
                });

                selectedPolyline = polyline;
            }

            highlightSidebarItem(sidebarItem);
        });
    }

    function highlightSidebarItem(item) {
        const timelineItems = document.querySelectorAll('.timeline-item');
        timelineItems.forEach((timelineItem) => {
            if (timelineItem === item) {
                timelineItem.classList.add('highlighted');
                timelineItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            } else {
                timelineItem.classList.remove('highlighted');
            }
        });
    }
    function getActivityIcon(activityType) {
        switch (activityType) {
            case 'IN_VEHICLE':
            case 'IN_PASSENGER_VEHICLE':
            case 'IN_TAXI':
                return 'üöó';
            case 'ON_BICYCLE':
            case 'CYCLING':
                return 'üö¥';
            case 'ON_FOOT':
            case 'WALKING':
            case 'WALKING_NORDIC':
                return 'üö∂';
            case 'STILL':
                return 'üõë';
            case 'UNKNOWN':
            case 'UNKNOWN_ACTIVITY_TYPE':
                return '‚ùì';
            case 'TILTING':
                return 'üì±';
            case 'RUNNING':
                return 'üèÉ';
            case 'FLYING':
                return '‚úàÔ∏è';
            case 'IN_BUS':
                return 'üöå';
            case 'IN_SUBWAY':
                return 'üöá';
            case 'IN_TRAIN':
                return 'üöÜ';
            case 'IN_TRAM':
                return 'üöä';
            case 'IN_CABLECAR':
                return 'üö†';
            case 'IN_FERRY':
                return '‚õ¥Ô∏è';
            case 'IN_FUNICULAR':
                return 'üöû';
            case 'IN_GONDOLA_LIFT':
                return 'üö°';
            case 'IN_WHEELCHAIR':
                return '‚ôø';
            case 'BOATING':
                return 'üö§';
            case 'CATCHING_POKEMON':
                return 'üéÆ';
            case 'HIKING':
                return 'ü•æ';
            case 'HORSEBACK_RIDING':
                return 'üêé';
            case 'KAYAKING':
                return 'üõ∂';
            case 'KITESURFING':
                return 'üèÑ‚Äç‚ôÇÔ∏è';
            case 'MOTORCYCLING':
                return 'üèçÔ∏è';
            case 'PARAGLIDING':
                return 'ü™Ç';
            case 'ROWING':
                return 'üö£';
            case 'SAILING':
                return '‚õµ';
            case 'SKATEBOARDING':
                return 'üõπ';
            case 'SKATING':
                return '‚õ∏Ô∏è';
            case 'SKIING':
                return '‚õ∑Ô∏è';
            case 'SLEDDING':
                return 'üõ∑';
            case 'SNOWBOARDING':
                return 'üèÇ';
            case 'SNOWMOBILE':
                return 'üöú';
            case 'SNOWSHOEING':
                return '‚ùÑÔ∏è';
            case 'SURFING':
                return 'üèÑ';
            case 'SWIMMING':
                return 'üèä';
            default:
                return '‚ùì';
        }
    }

    function getActivityColor(activityType) {
        switch (activityType) {
            case 'ON_FOOT':
            case 'WALKING':
            case 'RUNNING':
            case 'ON_BICYCLE':
            case 'CYCLING':
                return '#FF0000'; // Red
            case 'IN_VEHICLE':
            case 'IN_PASSENGER_VEHICLE':
            case 'IN_TAXI':
                return '#0000FF'; // Blue
            case 'IN_SUBWAY':
                return '#006400'; // Dark Green
            case 'IN_BUS':
                return '#800080'; // Purple
            default:
                return '#8B4513'; // Brown
        }
    }

    function formatActivityType(activityType) {
        switch (activityType) {
            case 'IN_VEHICLE':
            case 'IN_PASSENGER_VEHICLE':
                return 'In a Vehicle';
            case 'ON_BICYCLE':
            case 'CYCLING':
                return 'On a Bicycle';
            case 'ON_FOOT':
                return 'On Foot';
            case 'STILL':
                return 'Still';
            case 'UNKNOWN':
            case 'UNKNOWN_ACTIVITY_TYPE':
                return 'Unknown Travel';
            case 'TILTING':
                return 'Tilting';
            case 'WALKING':
                return 'Walking';
            case 'WALKING_NORDIC':
                return 'Nordic Walking';
            case 'RUNNING':
                return 'Running';
            case 'FLYING':
                return 'Flying';
            case 'IN_BUS':
                return 'On a Bus';
            case 'IN_SUBWAY':
                return 'On the Subway';
            case 'IN_TRAIN':
                return 'On a Train';
            case 'IN_TRAM':
                return 'On a Tram';
            case 'IN_CABLECAR':
                return 'In a Cable Car';
            case 'IN_FERRY':
                return 'On a Ferry';
            case 'IN_FUNICULAR':
                return 'On a Funicular';
            case 'IN_GONDOLA_LIFT':
                return 'In a Gondola Lift';
            case 'IN_WHEELCHAIR':
                return 'By Wheelchair';
            case 'BOATING':
                return 'Boating';
            case 'CATCHING_POKEMON':
                return 'Catching Pok√©mon';
            case 'HIKING':
                return 'Hiking';
            case 'HORSEBACK_RIDING':
                return 'Horseback Riding';
            case 'KAYAKING':
                return 'Kayaking';
            case 'KITESURFING':
                return 'Kitesurfing';
            case 'MOTORCYCLING':
                return 'Motorcycling';
            case 'PARAGLIDING':
                return 'Paragliding';
            case 'ROWING':
                return 'Rowing';
            case 'SAILING':
                return 'Sailing';
            case 'SKATEBOARDING':
                return 'Skateboarding';
            case 'SKATING':
                return 'Skating';
            case 'SKIING':
                return 'Skiing';
            case 'SLEDDING':
                return 'Sledding';
            case 'SNOWBOARDING':
                return 'Snowboarding';
            case 'SNOWMOBILE':
                return 'Snowmobiling';
            case 'SNOWSHOEING':
                return 'Snowshoeing';
            case 'SURFING':
                return 'Surfing';
            case 'SWIMMING':
                return 'Swimming';
            default:
                return 'Unknown';
        }
    }

    function initDatePicker() {
        const datePicker = document.getElementById('datePicker');
        datePicker.value = moment().format('YYYY-MM-DD');
        datePicker.addEventListener('change', (event) => {
            const selectedDate = new Date(event.target.value);
            loadTimelineDataInChunks(selectedDate);
        });

        document.getElementById('prevDayBtn').addEventListener('click', () => {
            const selectedDate = new Date(datePicker.value);
            selectedDate.setDate(selectedDate.getUTCDate() - 1);
            datePicker.value = moment(selectedDate).format('YYYY-MM-DD');
            loadTimelineDataInChunks(selectedDate);
        });

        document.getElementById('nextDayBtn').addEventListener('click', () => {
            const selectedDate = new Date(datePicker.value);
            selectedDate.setDate(selectedDate.getUTCDate() + 1);
            datePicker.value = moment(selectedDate).format('YYYY-MM-DD');
            loadTimelineDataInChunks(selectedDate);
        });
    }

async function readFilesFromDirectory(dirHandle) {
    let timelineJsonFile = null;

    // First, check for a single Timeline.json file
    for await (const entry of dirHandle.values()) {
        if (entry.kind === 'file' && entry.name === 'Timeline.json') {
            timelineJsonFile = entry;
            break;
        }
    }

    if (timelineJsonFile) {
        // If Timeline.json is found, load it directly
        try {
            const file = await timelineJsonFile.getFile();
            
            // Check file size before parsing
            if (file.size > 50 * 1024 * 1024) { // 50 MB limit
                console.warn('Timeline.json is very large. This may take some time to process.');
            }

            const content = await file.text();
            const data = JSON.parse(content);

            // Organize the data by year and month for compatibility with existing code
            const processedData = [];

			//Create array for the timelinePath points
            const processedTimelinePathObjects = [];

            // Check if it's the semantic segments format
			
			if (data.semanticSegments) {
				// Populate the timelinePath points from every timelinePath object
				data.semanticSegments.forEach(segment => {
					if (segment.timelinePath) {
                        segment.timelinePath.forEach(point => {
							const tempPoint = {
								latE7: Math.round(parseFloat(point.point.split('¬∞,')[0]) * 1e7),
								lngE7: Math.round(parseFloat(point.point.split('¬∞,')[1]) * 1e7),
								time:point.time
								};
							processedTimelinePathObjects.push(tempPoint);
						});	
					}
				});
				var timelinePathObjectsPointer = 0;  // Define pointer for path points loop below
				const processedTimelineObjects = data.semanticSegments.map(segment => {
                    if (segment.visit) {
                        // Convert semantic segments visit to a similar format as the original timeline objects
                        return {
                            placeVisit: {
                                location: {
                                    latitudeE7: Math.round(parseFloat(segment.visit.topCandidate.placeLocation.latLng.split('¬∞,')[0]) * 1e7),
                                    longitudeE7: Math.round(parseFloat(segment.visit.topCandidate.placeLocation.latLng.split('¬∞,')[1]) * 1e7),
                                    placeId: segment.visit.topCandidate.placeId,
                                    semanticType: segment.visit.topCandidate.semanticType,
                                    name: 'Unknown Location'
                                },
                                duration: {
                                    startTimestamp: segment.startTime,
                                    endTimestamp: segment.endTime
                                }
                            }
                        };
                    } else if (segment.activity) {
                        // Define activitySegment properly here
                        const activitySegment = {
                            activityType: segment.activity.topCandidate.type || 'UNKNOWN',
                            duration: {
                                startTimestamp: segment.startTime,
                                endTimestamp: segment.endTime
                            },
                            distance: segment.activity.distanceMeters,
                            startLocation: {
                                latitudeE7: Math.round(parseFloat(segment.activity.start.latLng.split('¬∞,')[0]) * 1e7),
                                longitudeE7: Math.round(parseFloat(segment.activity.start.latLng.split('¬∞,')[1]) * 1e7)
                            },
                            endLocation: {
                                latitudeE7: Math.round(parseFloat(segment.activity.end.latLng.split('¬∞,')[0]) * 1e7),
                                longitudeE7: Math.round(parseFloat(segment.activity.end.latLng.split('¬∞,')[1]) * 1e7)
                            },
							simplifiedRawPath: {
								distanceMeters: segment.activity.distanceMeters,
								points: []
							}
                        };
						// Add simplified raw path if timelinePath exists
						// Find the associated timelinePath points for this activitySegment
						for (let i = timelinePathObjectsPointer; i < processedTimelinePathObjects.length; i++) {
							const point = processedTimelinePathObjects[i];
							
							if (point.time >= activitySegment.duration.startTimestamp && point.time <= activitySegment.duration.endTimestamp) {
								activitySegment.simplifiedRawPath.points.push(point)
							};
							if (point.time > activitySegment.duration.endTimestamp) {
								timelinePathObjectsPointer = i;
								break;
							}
						};
                        return {
                            activitySegment: activitySegment
                        };
                    }
                }).filter(Boolean); // Remove any undefined entries

                // Group by year and month
                processedTimelineObjects.forEach(item => {
                    const timestamp = item.placeVisit 
                        ? item.placeVisit.duration.startTimestamp 
                        : item.activitySegment.duration.startTimestamp;
                    const date = new Date(timestamp);
                    const key = `${date.getFullYear()}_${date.toLocaleString('default', { month: 'long' }).toUpperCase()}`;
                    
                    if (!processedData[key]) {
                        processedData[key] = { timelineObjects: [] };
                    }
                    processedData[key].timelineObjects.push(item);
                });

                timelineData = processedData;
            } 
            // Fallback for original Google Takeout format
            else if (data.timelineObjects) {
                timelineData = data;
            }

            console.log('Timeline.json loaded successfully');
        } catch (err) {
            console.error('Error parsing Timeline.json:', err);
        }
    } else {
        // Fallback to original method of reading multiple JSON files
        for await (const entry of dirHandle.values()) {
            if (entry.kind === 'file' && entry.name.endsWith('.json')) {
                const file = await entry.getFile();
                const content = await file.text();
                const data = JSON.parse(content);
                const fileName = entry.name.split('.')[0]; // Assuming filename format is YYYY_MONTH.json
                timelineData[fileName] = data;
            } else if (entry.kind === 'directory') {
                await readFilesFromDirectory(entry);
            }
        }
    }
}


    async function initFolderPicker() {
        const folderPicker = document.getElementById('folderPicker');
        folderPicker.addEventListener('click', async () => {
            try {
                const dirHandle = await window.showDirectoryPicker();
                await readFilesFromDirectory(dirHandle);
                console.log('Files loaded:', Object.keys(timelineData));
                // Load data for the currently selected date
                loadTimelineDataInChunks(new Date(document.getElementById('datePicker').value));
            } catch (err) {
                console.error('Error selecting folder:', err);
            }
        });
    }

    window.onload = () => {
        initMap();
        initDatePicker();
        initFolderPicker();
        const initialDate = new Date('2024-02-16');
        document.getElementById('datePicker').value = moment(initialDate).format('YYYY-MM-DD');
    };

</script>
</body>
</html>
